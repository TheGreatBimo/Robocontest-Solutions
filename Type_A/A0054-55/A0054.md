[Problem link](https://robocontest.uz/tasks/A0054)
[Problem link](https://robocontest.uz/tasks/A0054)
#### Translation
Bitboy has a coin. When tossed repeatedly, it never lands tails three times in a row.
Determine the number of possible sequences of coin tosses when the coin is tossed N times.

#### Solution
THE PROBLEM HAS TWO VERSIONS, THE ONLY DIFFERENCE IS IN CONSTRAINTS (1000ms vs 500ms)
THE SOLUTION HERE IS SUITABLE FOR BOTH!

Let's define a dp where:
dp[i] = (a,b,c)
a is the number of sequences with length i that end with 0 tails
b is the number of sequences with length i that end with 1 tails
c is the number of sequences with length i that end with 2 tails
(and we can't have any sequence that end with 3 tails!)

dp[1] is (1,1,0)
because we have only 2 combinations:
|-----|-----|
|tails|heads|

let's see what dp 2 is
we have 4 combinations:
|-----|-----|-----|-----|
|tails|tails|heads|heads|
|tails|heads|tails|heads|

2 of them end with 0 tails, 1 of them ends with 1 tails, 1 of them ends with 2 tails

what is the transformation?
suppose dp[i-1] = (a,b,c)
we need to compute dp[i]

in order to get a sequence ending with 0 tails we just have to get heads, and the previous sequence doesn't matter,
so we can just add all previous sequences
dp[i][0] = a+b+c
in order to get a sequence ending with 1 tail we have to drop tails AFTER a sequence with 0 tails,
dp[i][1] = a
and in order to get a sequence ending with 2 tails with have to drop tails after a sequence ending in 1 tail.
dp[i][2] = b

so during transformation we turned:
(a,b,c)
into
(a+b+c,a,b)

so we can just do linear transformation, precompute all the answers to get the answer for any i.

But wait, isn't constraint for N 1e18 in both problems, we need at least logN solution!

notice the transformation: in order to transform a vector, we have to multiply it to a matrix of the transformation
and in order to get (a+b+c, a, b) from (a, b, c)
we need the following matrix:
| - | - | - |
| 1 | 1 | 1 |
| 1 | 0 | 0 |
| 0 | 1 | 0 |
this matrix is also known as the Tribonacci transformation matrix.

What we do now is:
for every i we multiply v*M^(i-1)
where v = (1,1,0)
and M is Tribonacci matrix.

You may ask: "How did that make the solution more efficient?"
The thing is we can do exponentiation operation with matrices in O(logN) time:
we precompute powers of matrix (specifically 1,2,4,8...2^n th powers) and later use them in matrix binary exponentiation.
We multiply our vector by the final matrix and voila!

Complexity of this algoritm is O(logN) for each test, and it works for the second problem as well with:
#pragma GCC optimize("O3")